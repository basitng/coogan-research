React Query, a react library that simplifies the way we fetch, cache and synchronize data from a server. React itself has no opinions about how you fetch data from the front end. The most basic approach is to use the browser fetch API when a component first mounts in Use Effect, then manage the response with Use State. That works, but becomes increasingly difficult when requirements like Caching, Retries and Deduping come into play. React Query not only simplifies your data fetching code, but also handles these complex requirements out of the box. For example, you might want to refresh data when the user leaves and then comes back to the same window. Fetch on Window Focus handles that for you. If you're building an infinite scroll feature, the Use Infinite Query hook will make your life much easier. Or if you're writing data to the server, you can make changes appear instantly in the UI with optimistic updates. And you can debug all your data fetching logic with its integrated DevTools. They've thought of pretty much everything, and it's so good at what it does that it might even eliminate your need for a global state management solution. To get started, install it with NPM, then instantiate the query client and provide it somewhere in your component tree. Now, every child component will be able to fetch data like a pro. Also add the React Query DevTools here to debug and development. Now, define a function anywhere you'd like to fetch data from your server and the component that consumes that data. Add the use query hook. It takes a key that allows React Query to manage this data efficiently, then the data fetching function as the second argument it will make. The request, then return the data and also the status of the request. If it's loading, we show a loading screen. If the request fails, it will actually retry the request three times, and if it still fails at that point, the status will change to error. Now, if it was a success, we can render out the data in the UI, and that's a lot of functionality with not a lot of code. But you might be wondering what this key is all about. Well, now let's imagine that we want to update this data on the server. To handle that, we can bring in the Use Mutation hook. When data is written to the server, we can hook into it with the On Success function and automatically invalidate the query we already made based on its key. This tells React Query to invalidate and refresh the original request. And we can even tap into the state of this process by referencing is Fetching from Use Query to keep tabs on the loading state. Now, if you want to run multiple queries in the same component, you can easily do that, and it will automatically run them in parallel to ensure optimal performance. But sometimes one query might depend on data from another. Like all the cars owned by a user that's also made easy with the enabled option. Like I said before, they've thought of everything. This has been React query in 100 seconds. If you want to see more content like this, enroll in my full React course on fireship I O. That breaks down a ton of React concepts in 100 seconds or less. Thanks for watching and I will see you in the next one.